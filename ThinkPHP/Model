					Model


1.模型操作（Application/Home/Model）

	(1)常规配置（pdo）
		1.配置数据库链接
	
		Home/Conf/config.php
	
		'db_type'    =>   'mysql',
		'db_host'    =>   '127.0.0.1',
		'db_user'    =>   'root',
    		'db_pwd'     =>   '12345',
    		'db_port'    =>    3306,
    		'db_name'    =>    'students', 
    		'db_charset' =>    'utf8',
		'show_page_trace' => true, 用于调试

		2.编写控制器

			2.1使用Model('数据表名')类；直接实例化基类Model，需要导入命名空间
		
				use Think/Model		

				$link=new Model("数据表名");
	         		echo "<pre>";
	         		var_dump($link->select());
	         		echo "</pre>";

		
			2.2使用Model的全局M('数据表名')函数；不需要导入命名空间，适用于CURD操作	
		
				$link=M('user');
				echo "<pre>";
	        		var_dump($link->select());
	        		echo "</pre>";
			

	（2）定义新模型，继承Model父类，适用于独立数据库操作

		1.编写数据库操作Model（/Home/Model/数据表名Model.class.php）
			
			namespace Home\Model;
			use Think\Model;

			class UsersModel extends Model{

			}

		2.编写控制器
			
			2.1.直接实例化类UsersModel，需要导入命名空间
				
				use Home\Model\UsersModel;
	
				$link =new UsersModel();
	        		echo "<pre>";
	        		var_dump($link->select());
	        		echo "</pre>";


			2.2.使用UsersModel的全局D('数据表名')函数；不需要导入命名空间；他先会找/Home/Model/UsersModel，在找Common/Model/UsersModel
			，最后变成M()函数


				$link=D('users');
				echo "<pre>";
	        		var_dump($link->select());
	        		echo "</pre>";

	（3）字段缓存,有利于io速度，只用于生产模式（Runtime/Data/_fields）

		1.关闭开发模式会有字段缓存，入口文件中的
			define('APP_DEBUG',True);

		2.在配置文件中指明关闭缓存
			'db_fields_cache'=>false;
	
	

2.sql操作

	（1）基本查询

		a.字符串查询,不安全

		$link->where('id=1 and class=103')->select();
		==>	SELECT * FROM `users` WHERE ( id=1 and class=103 ) 


		b.索引数组查询,推荐使用	$con[_logic]='or';改变逻辑
		
		$con['id']=1;
     		$con['class']='103';
     		$link->where($con)->select();
		==>	SELECT * FROM `users` WHERE `id` = 1 AND `class` = '103'
	
		c.对象方式查询
		
		$con =new \stdClass();
	     	$con->id=1;
     		$con->class='103';
     		$link->where($con)->select();
		==>	SELECT * FROM `users` WHERE `id` = 1 AND `class` = '103'

	(2)表达式查询   【 $map['字段']=array('表达式','查询条件') 】

		表达式

		eq	=		neq	!=		gt	>		egt	>=
		lt	<		elt	<=		[not]like		[not] between
		[not] in		

		
		 $con['id']=array('eq',1);
     		 $link->where($con)->select();
		 ==>	SELECT * FROM `users` WHERE `id` = 1;

		$con['id']=array('between',array(1,3));
	     	$link->where($con)->select();
		==>	SELECT * FROM `users` WHERE `id` BETWEEN 1 AND 3;
		
		$con['id']=array('in',array(1,2,3));
     		$link->where($con)->select();
		==>	SELECT * FROM `users` WHERE `id` IN (1,2,3);

		
	(3)快捷查询    【 字段|字段  字段&字段 】

		a.不同字段相同查询条件

		$map['id|class']=1;
		$link->where($con)->select();
		==>	SELECT * FROM `users` WHERE ( `id` = 1 OR `class` = 1 );


		b.不同字段不同查询条件,'_multi'字段指定 一 一 对应

		 $con['id&class']=array(1,'103','_multi'=>true);
                 $link->where($con)->select();
		 ==>	SELECT * FROM `users` WHERE ( (`id` = 1) AND (`class` = '103') );


		c.支持表达式查询
		
		$con['id&class']=array(array('gt',1),'103','_multi'=>true);
          	$link->where($con)->select();
		==>	SELECT * FROM `users` WHERE ( (`id` > 1) AND (`class` = '103') );



	(4)区间查询  【 $map['字段']=array(array('表达式','查询条件'),array('表达式','查询条件'),'逻辑符') 】

		$con['id']=array(array('gt',1),array('lt',3),'or');
    		$link->where($con)->select();
		==>	SELECT * FROM `users` WHERE ( `id` > 1 OR `id` < 3 );


	(5)统计查询	【 count() ， max() ， min() ， avg() ， sum() 】

			 
		$link->count();
		==>	SELECT COUNT(*) AS tp_count FROM `users` LIMIT 1;

		$link->count('id');
		==>SELECT COUNT(id) AS tp_count FROM `users` LIMIT 1;

	(6)原生sql查询	【 query('sql语句')	execute('sql语句') 】

		1.query读取
		
		$link->query('select * from users')
		==>	select * from users;


		2.execute执行

		$link->execute("insert into users values(7,'li','104')")
		==>	insert into users values(7,'li','104')


	(7)连贯操作

		a.【 where('条件') 】（支持多次调用）

		 $con1['id']=array('gt',1);
	     	 $con2['class']='103';
     		 $link->where($con1)->where($con2)->select();
		 ==>	SELECT * FROM `users` WHERE `id` > 1 AND `class` = '103';

		b.【 order(array('字段'=>'desc|esc')) 】
		
		 $con['id']=array('gt',1);
     		 $link->where($con)->order(array('id'=>'desc'))->select();
		==>	SELECT * FROM `users` WHERE `id` > 1 ORDER BY `id` desc;

		c.【 field('字段') 】
		
		$link->field('id','name')->select();
		==>	SELECT `name`,`class` FROM `users` ;


		d.【 limit(n1[,n2]) 】
	
		$link->limit(1,2)->select();
		==>	SELECT * FROM `users` LIMIT 1,2;


		e.【 group('字段名') 】

		$link->group('id')->select();
		==>	SELECT * FROM `users` GROUP BY id;

		f.【 having('查询条件')) 】

		$link->group('id')->having("id>1")->select();
		==>	SELECT * FROM `users` GROUP BY id HAVING id>1;
		

		g.【 join('查询条件','RIGTH | LEFT | FULL ')】

		h.【 union('sql语句') 】

		i.【 distinct(true | false) 】



3.命名范围（将sql操作封装成Model）

	 protected $_scope=array(
        
      	'sql1'=>
            	array('where'=>array('id'=>1)) ,
        'sql2'=>
            	array('order'=>'id desc','limit'=>2)
        
    	);

	==========================================

	$link->scope('sql1')->select();
	或
	$link->sql1()->select();



		
4.CURD  
	
	创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作

	(1)接受数据

		create('$_POST | $_GET')：默认post接受，只接受与数据库相同的字段
		
		//直接获取数据
		$link->create();

		//数组手动获取数据
		$data['name']=$_POST['name'];
    		$data['class']=$_POST['class'];
    		$data['id']=$_POST['birth'];
    		$link->create($data);


		//对象手动获取
		$data=new \stdClass();
		$data->name=$_POST['name'];
		$data->class=$_POST['class'];
    		$data->id=$_POST['birth'];
    		$link->create($data);


	(2)创建数据

		$data['name']=$_POST['name'];
    		$data['class']=$_POST['class'];
    		$data['id']=$_POST['birth'];
    		$link->add($data);
		==>	INSERT INTO `users` (`name`,`class`,`id`) VALUES ('web','103','10');

		$data['name']=$_POST['name'];
	    	$data['class']=$_POST['class'];
    		$data['id']=$_POST['birth'];
    		$link->add($link->create($data));
		==>	INSERT INTO `users` (`name`,`class`,`id`) VALUES ('www','103','9');

	
	(3)读取数据
		
		//只显示第一行记录
		$link->find();
		==>	SELECT * FROM `users`;

		//显示全部记录
		$link->select();
		==>	SELECT * FROM `users` LIMIT 1;

		
	(4)更新数据
		
		//自动识别主键
		$data['name']='zhangsan1';
		$data['class']='103';
		$data['id']=1;
		$link->save($data);
		==>	UPDATE `users` SET `name`='zhangsan1',`class`='103' WHERE `id` = 1 

		//指定条件
		$data['name']='zhangsan1';
		$data['class']='103';
		$map['id']=1;
		$link->where($map)->save($data);
		==>	UPDATE `users` SET `name`='zhangsan1',`class`='103' WHERE `id` = 1 


	(5)数据删除
		
		//根据主键值删除,一次性可以指定多个
		$link->delete(1);
		==>	DELETE FROM `users` WHERE `id` = 1;

		//根据条件删除
		$map['id']=1;
		$link->where($map)->delete();
		==>	DELETE FROM `users` WHERE `id` = 1;

		//全部删除
		$link->where('1')->delete();



	(6)ActiveRecord模式
	
		将CURD对象化

		//增加数据
		$link->name="zhangsan";
        	$link->class="103";
        	$link->id=1;
        	$link->add();
		==>	INSERT INTO `users` (`name`,`class`,`id`) VALUES ('zhangsan','103','1');


		//修改数据
		$link->name="zhangsan1";
        	$link->class="103";
        	$link->id=1;
        	$link->save();
		==>	UPDATE `users` SET `name`='zhangsan1',`class`='103' WHERE `id` = 1;


		//删除数据
		$link->name="zhangsan1";
        	$link->class="103";
        	$link->id=1;
        	$link->delete();
		==>	DELETE FROM `users` WHERE `id` = 1;

		//读取数据
		$link->select(3);
		==>	SELECT * FROM `users` WHERE `id` = 3;

	(7)字段映射(字段别名)
		
		改变create()方法接受默认指定字段名
		UsersModel类中
		
		protected  $_map=array(
		            'birth'=>'id'
            
	        );




5.自动验证

	（1）静态验证	在Model中验证

	protected $_validate=array(
       		array(验证字段,验证规则,错误提示[,验证条件,附加条件,验证时间]),
        );

	protected $patchValidate=true;  //批量验证

		验证规则：require 字段必须、email 邮箱、url URL地址、currency 货币、number 数字。

		验证条件：	self::EXISTS_VALIDATE 或者0 存在字段就验证（默认）
				self::MUST_VALIDATE 或者1 必须验证
				self::VALUE_VALIDATE或者2 值不为空的时候验证
		
		附加规则:	regex	正则验证，定义的验证规则是一个正则表达式（默认）
				equal	验证是否等于某个值，该值由前面的验证规则定义
				notequal	验证是否不等于某个值，该值由前面的验证规则定义
				confirm	验证表单中的两个字段是否相同，定义的验证规则是一个字段名
				in	验证是否在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串
				notin	验证是否不在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串
				length	验证长度，定义的验证规则可以是一个数字（表示固定长度）或者数字范围（例如3,12 表示长度从3到12的范围）
				between	验证范围，定义的验证规则表示范围，可以使用字符串或者数组，例如1,31或者array(1,31)
				notbetween	验证不在某个范围，定义的验证规则表示范围，可以使用字符串或者数组
				callback	方法验证，定义的验证规则是当前模型类的一个方法
				function	函数验证，定义的验证规则是一个函数名(函数在Common下的function.php中)

		验证时间：	self::MODEL_INSERT或者1新增数据时候验证
				self::MODEL_UPDATE或者2编辑数据时候验证
				self::MODEL_BOTH或者3全部情况下验证（默认）


	a.使用内置验证规则

		UsersModel类

		protected $_validate=array(
       			
			array('name','require','用户名不能为空')
		   );

		UserController类

		$data['name']='';
		
		if($link->create($data)){
		          echo "<meta charset=utf8 />";
		          echo "验证成功";
	        }else{
		          echo "<meta charset=utf8 />";
		          var_dump($link->getError()); 
	        }

	b.使用附加规则
		
		1)	array('name','/^\d{3,6}$/','不是3-6数字',0,'regex')

		2)	array('name','lisi','名字不一致',0,'equal')

		3)	array('name','class','字段name与class不相等',0,'confirm')

		4)	array('id',array(1,2,3),'字段id不在指定范围内',0,'in')

		5)	array('name','checkLength','用户名在3-5位',0,'callback',3,array(3,5))

			 protected function checkLength($str,$v1,$v2){
	      			preg_match_all('/./u', $str, $matches);
		        	$len=count($matches[0]);
                        	if($len < $v1 || $len > $v2){
        				return false;   
      				}else{
			        	return true;
		        	}
			 }

		6)	array('name','checkLength','用户名在3-5位',0,'function',3,array(3,5))

			Common/function.php
		
		 	protected function checkLength($str,$v1,$v2){
	      			preg_match_all('/./u', $str, $matches);
		        	$len=count($matches[0]);
                       		if($len < $v1 || $len > $v2){
        				return false;   
      				}else{
			        	return true;
		        	}
		 	}

	(2)动态验证  直接在Controller中验证

		$rule =array(
			array('name','require','用户名不能为空')
		);

		$data['name']='';
		
		if($link->validate($rule)->create($data)){
		          echo "<meta charset=utf8 />";
		          echo "验证成功";
	        }else{
		          echo "<meta charset=utf8 />";
		          var_dump($link->getError()); 
	        }




6.自动完成

	（1）静态方式	在Model中定义


		protected $_auto = array(
            		array(完成字段,完成规则,[完成条件,附加规则])	
                );


		完成条件：	self::MODEL_INSERT或者1	新增数据的时候处理（默认）
				self::MODEL_UPDATE或者2	更新数据的时候处理
				self::MODEL_BOTH或者3	所有情况都进行处理

		附加规则：	function	使用函数，表示填充的内容是一个函数名
				callback	回调方法 ，表示填充的内容是一个当前模型的方法
				field	用其它字段填充，表示填充的内容是一个其他字段的值
				string	字符串（默认方式）
				ignore	为空则忽略


	a.自动填充（修改）

		1）	array('class','103');

			$data['name']='dd';		//这里只能写一条数据，其他可由array自动填充
	    		if($link->create($data)){
        			$link->add();
    			}

			==>	INSERT INTO `users` (`name`,`class`) VALUES ('dd','103') 


	b.附加规则

		1)	array('name','sha1',3,'function')	使用系统内置函数sha1给name字段加密

		2)	array('name','class',3,'field')		将class字段值填充name

		3)	array('name','updateUser',3,'callback',"_")	给name字段值前加"_"

			protected function updateUser($str,$v){
				return $v.$str;
			}

		4)	array('id','',2,'ignore')		当id值为空，则不对id值修改


	(2)动态方式	在Controller中

		$data['name']='ddd';
		
		$rule=array(
         		array('id','19')
	     	);
    		if($link->auto($rule)->create($data)){
        		$link->add();
       		}

