							JavaScript(二)
							
			
1.继承

	(1)原型链继承
			核心:将父类的实例作为子类的原型
			
		function Cat(){ }
		Cat.prototype = new Animal();
		Cat.prototype.name = 'cat';

		var cat = new Cat();
		console.log(cat instanceof Animal); //true 
		console.log(cat instanceof Cat); //true
		
	特点：
		a.非常纯粹的继承关系，实例是子类与父类的实例
		b.父类新增原型方法/原型属性，子类都能访问到
	缺点：
		a.要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
		b.无法实现多继承
		c.来自原型对象的【引用属性】是共享的
		d.创建子类实例时，无法向父类构造函数传参
		
		function Animal (name) {

		this.name = name || 'Animal';
		//实例【引用属性】
		this.features = [];
		}

		function Cat(name){	}
		Cat.prototype = new Animal();

		var tom = new Cat('Tom');
		var kissy = new Cat('Kissy');
		
--------------------------无法传参---------------------------------
		console.log(tom.name); // "Animal"
		console.log(kissy.name); // "Animal"
		
-------------------------引用类型共享-------------------------------
		console.log(tom.features); // []
		console.log(kissy.features); // []
		tom.features.push('eat');
		console.log(tom.features); // ['eat']
		console.log(kissy.features); // ['eat']
		
		
	(2)构造继承
		使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
		
		function Cat(name){
			Animal.call(this);
			this.name = name || 'Tom';
		}


		var cat = new Cat();
		console.log(cat instanceof Animal); // false
		console.log(cat instanceof Cat); // true
		
	特点：
		a.解决了1中，子类实例共享父类引用属性的问题
		b.创建子类实例时，可以向父类传递参数
		c.可以实现多继承（call多个父类对象）
	缺点：
		a.实例并不是父类的实例，只是子类的实例
		b.只能继承父类的实例属性和方法，不能继承原型属性/方法
		c.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
		
	(3)实例继承
		为父类实例添加新特性，作为子类实例返回

		function Cat(name){
			var instance = new Animal();
			instance.name = name || 'Tom';
			return instance;
		}

		var cat = new Cat();
		console.log(cat instanceof Animal); // true
		console.log(cat instanceof Cat); // false

		特点：
			a.不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果
		缺点：
			a.实例是父类的实例，不是子类的实例
			b.不支持多继承
			
	(4)拷贝继承

		function Cat(name){
			var animal = new Animal();
			for(var p in animal){
			Cat.prototype[p] = animal[p];
		}
		Cat.prototype.name = name || 'Tom';
		}

		var cat = new Cat();
		console.log(cat instanceof Animal); // false
		console.log(cat instanceof Cat); // true
		
		特点：
			a.支持多继承
		缺点：
			a.效率较低，内存占用高（因为要拷贝父类的属性）
			b.无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）
			
	(5)组合继承
		
		通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数
	复用

		function Cat(name){
			Animal.call(this);
			this.name = name || 'Tom';
		}
		Cat.prototype = new Animal();

		var cat = new Cat();
		console.log(cat instanceof Animal); // true
		console.log(cat instanceof Cat); // true
	
	特点：
		a.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
		b.既是子类的实例，也是父类的实例
		c.不存在引用属性共享问题
		d.可传参
		e.函数可复用
	缺点：
		a.调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
