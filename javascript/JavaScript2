							JavaScript(二)
							

1.事件流

	（1）两种事件流模型

		冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。

		捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。

	（2）DOM事件流

		DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。

		DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。
			事件捕获阶段：实际目标在捕获阶段不会接收事件。但是实际中都会在捕获阶段触发事件对象上的事件。
			处于目标阶段：事件在目标上发生并处理。事件处理会被看成是冒泡阶段的一部分。
			冒泡阶段：事件又传播回文档。

		======================================================================
			<div id="outer">
			    <div id="middle">
        			<div id="inner">
            				click me!
        			</div>
    			    </div>
			</div>


		当点击时:
		outer -> middle -> inner -> inner -> middle -> outer
		
		======================================================================

	(3)事件处理程序

		=======================================================================
		
		1.html事件处理程序

		<button onclick="fun1()">点击</button>
		<script>
			function fun1(){
				console.log(event);	//返回事件对象	
			}
		</script>
		
		=======================================================================
		
		2.DOM0级事件处理程序
		
			只能为一个元素添加一个事件处理函数

		<button id="btn">点击</button>
		<script>
	   		 var myBtn=document.getElementById("btn");
    			 myBtn.onclick=function(){
        			console.log(event);
    			 }
		
			 myBtn.onclick=null; //删除事件
		</script>

		===========================================================================
		
		3.DOM2级事件处理程序

			可以为一个元素天剑多个事件

			<button id="btn">点击</button>
			<script>
    				var myBtn=document.getElementById("btn");
    				
				myBtn.addEventListener("click",function(){
        				alert("hello");	
    				},false);
    				
				myBtn.addEventListener("click",function(){
				        alert("world");
    				},false);
			</script>

		
			addEventListener()和removeEventListener()。
		
			这两个方法都需要3个参数：事件名，事件处理函数，布尔值。
	
			true,在捕获阶段处理事件，
			false，在冒泡阶段处理事件，默认为false。


			通过addEventListener添加的事件处理程序必须通过removeEventListener删除，且参数一致。
			且不能是匿名函数，如下
			
				 myBtn.removeEventListener("click",function(){
				        alert("world");
				  },false);
		=========================================================================
		
		4.event对象
		
		属性:
		type属性，用于获取事件类型
		target属性，用户获取事件目标 事件加在哪个元素上。（更具体target.nodeName）
		currentTarget属性，其事件处理程序当前正在处理事件的那个元素（currentTarget始终===this,即处理事件的元素）

		方法：
		stopPropagation()方法 用于阻止事件冒泡
		preventDefault()方法 阻止事件的默认行为 移动端用的多
		stopImmediatePropagation()可以阻止之后事件处理程序被调用。
	


			
2.继承

	(1)原型链继承
		核心:将父类的实例作为子类的原型
			
		function Cat(){ }
		Cat.prototype = new Animal();
		Cat.prototype.name = 'cat';

		var cat = new Cat();
		console.log(cat instanceof Animal); //true 
		console.log(cat instanceof Cat); //true
		
	特点：
		a.非常纯粹的继承关系，实例是子类与父类的实例
		b.父类新增原型方法/原型属性，子类都能访问到
	缺点：
		a.要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
		b.无法实现多继承
		c.来自原型对象的引用属性（Array等）是共享的
		d.创建子类实例时，无法向父类构造函数传参
		
		
		
		
	(2)构造继承
		使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
		
		function Cat(name){
			Animal.call(this);
			this.name = name || 'Tom';
		}


		var cat = new Cat();
		console.log(cat instanceof Animal); // false
		console.log(cat instanceof Cat); // true
		
	特点：
		a.解决了1中，子类实例共享父类引用属性的问题
		b.创建子类实例时，可以向父类传递参数
		c.可以实现多继承（call多个父类对象）
	缺点：
		a.实例并不是父类的实例，只是子类的实例
		b.只能继承父类的实例属性和方法，不能继承原型属性/方法
		c.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
	

	
	(3)实例继承
		为父类实例添加新特性，作为子类实例返回

		function Cat(name){
			var instance = new Animal();
			instance.name = name || 'Tom';
			return instance;
		}

		var cat = new Cat();
		console.log(cat instanceof Animal); // true
		console.log(cat instanceof Cat); // false

		特点：
			a.不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果
		缺点：
			a.实例是父类的实例，不是子类的实例
			b.不支持多继承
			
	(4)拷贝继承

		function Cat(name){
			var animal = new Animal();
			for(var p in animal){
				Cat.prototype[p] = animal[p];
			}
			Cat.prototype.name = name || 'Tom';
		}

		var cat = new Cat();
		console.log(cat instanceof Animal); // false
		console.log(cat instanceof Cat); // true
		
		特点：
			a.支持多继承
		缺点：
			a.效率较低，内存占用高（因为要拷贝父类的属性）
			b.无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）
		

	
	(5)组合继承
		
		通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数
	复用

		function Cat(name){
			Animal.call(this);
			this.name = name || 'Tom';
		}
		Cat.prototype = new Animal();

		var cat = new Cat();
		console.log(cat instanceof Animal); // true
		console.log(cat instanceof Cat); // true
	
	特点：
		a.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
		b.既是子类的实例，也是父类的实例
		c.不存在引用属性共享问题
		d.可传参
		e.函数可复用
	缺点：
		a.调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
