 # 字节对齐


### 一.字节对齐

>字节对齐的根本原因在于CPU访问数据的效率问题。假设上面int变量的地址不对齐，比如存放地址为0x0002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x0002-0x003的一个short，第二次取从0x0004-0x0005的一个short然后组合得到所要的数据，而如果变量在对齐位置上，则只要一次就可以取出数据。

<br>

### 二.对齐原则

 ```
1.基本数据类型自身的对齐值
2.结构体的自身对齐值(其成员中自身对齐值最大的那个值)
3.指定对齐值：#pragma pack (value)时的指定对齐值value(默认为4字节)
4.有效对齐值(自身对齐值和指定对齐值中小的那个值)
 ```

实例1：

```cpp
struct A{
    char a;
    int b;
    short c;
};
```

分析1:

```
1.结构体A从地址空间0x0000开始排放，默认指定对齐值为4
2.变量a的自身对齐值是1，有效对齐值为1，其存放地址0x0000符合0x0000%1=0
3.变量b的自身对齐值为4，有效对齐值为4，其存放地址0x0004符合0x0004%4=0
4.变量c的自身对齐值为2，有效对齐值为2，其存放地址0x0008符合0x0008%2=0
5.结构体A的自身对齐值为4，有效对齐值为4。根据结构体圆整的要求0x0000到0x000B=12字节,12％4＝0
```

实例2:

```cpp
#pragma pack (2)
struct B{
    char a;
    int b;
    short c;
};
#pragma pack ()
```

分析2:

```
1.结构体B从地址空间0x0000开始排放，指定对齐值为2
2.变量a的自身对齐值是1，有效对齐值为1，其存放地址0x0000符合0x0000%1=0
3.变量b的自身对齐值为4，有效对齐值为2，其存放地址0x0002符合0x0002%2=0
4.变量c的自身对齐值为2，有效对齐值为2，其存放地址0x0006符合0x0006%2=0
5.结构体B的自身对齐值为4，有效对齐值为2。根据结构体圆整的要求0x0000到0x0007=8字节,8％4＝0
```
