					ruby元编程


1.动态方法

	(1)动态调用方法
	
	在Ruby中通过Object#send方法可以代替点标识调用对象的指定实例方法

	================================================================
		class MyClass
	    		def get1
			    puts "get1"
			end
		
			def get2
			   puts "get2"	
			end

			def get3
		 	   puts "get3"
			end
		end

		obj = MyClass.new
		name = 1
		obj.send(:"get#{name}")	=>get1
	
	上面代码通过直接调用和使用send方法调用得到的结果是一样的
	通过Object#send不仅可以调用公共方法，也可以调用对象的私有方法。
	如果想保留对象的封装特性，不向外暴露私有方法可以使用Object#public_send方法。
	================================================================	

	（2）动态定义方法
	
	通过Module#define_method方法和代码块提供了动态方法定义方式
	
	================================================================
		class MyClass
    			define_method :get do |arg|
       				puts "get#{arg}"
		        end
		end

		obj = MyClass.new
		obj.get(1)  #=> get1
		
	
	================================================================
	
	(3)method_missing方法
	
	method_missing利用的机制是，当一个对象进行某个方法调用的时候，会到其对应的类的实例方法中进行查找，
	如果没有找到，则顺着祖先链向上查找，直到找到BasicObject类为止。如果都没有则会最终调用一个
	BasicObject#method_missing抛出NoMethodError异常。

	===================================================================
		class SendClass  
  			def method_missing(name, *argc)  
    				if [:one_name, :two_name, :three_name].include?(name)  
      					name  
    				else 	#处理不了的方法就让父类处理  
      					super  
    				end  
  			end  
		end  
  
		s = SendClass.new  
  
		puts s.one_name    #one_name  
		puts s.four_name   #undefined method `four_name'  

	===================================================================

	(4)删除方法

	====================================================================
		class A
  			def fun1
      				puts "ok"
  			end
		end

		class B<A
		    def fun1
      			puts "ok1"
    		    end
    			
		    remove_method :fun1
		end

		B.new.fun1
		>ok
		
	undef_method会删除所有(包括继承而来的)方法。而remove_method只删除接受者自己的方法，而保留继承来的方法。
	==================================================================


2.ruby作用域

	Ruby中不具备嵌套作用域(即在内部作用域，可以看到外部作用域的)的特点，它的作用域是截然分开的，一旦进入一个

新的作用域，原先的绑定会被替换为一组新的绑定。类定义class 模块定义 module  方法定义 def

	(1)扁平化作用域（局部变量）
	
	=======================================================================
	my_var = "Success"
	MyClass = Class.new do
    		puts "#{my_var} in  the class definition"

    		define_method :my_method do
        		puts "#{my_var} in the method"
    		end
	
	end

	obj2=MyClass.new
	obj2.my_method

	Class.new替代class
	Module#define_method代替def
	Module.new代替module
	======================================================================
	
	(2)BasicObject#instance_eval{代码块}
		
		可以访问到调用者对象中的变量（实例变量）

	=====================================================================
	class MyClass

	  def initialize
        	@v = 1
    	  end

	end

	obj = MyClass.new
	puts obj.instance_eval { @v } 
	obj.instance_eval{@v=3}
	puts obj.instance_eval { @v } 
	=======================================================================


	（3）BasicObject#instance_exec(参数){|参数列表| }
		与instance_eval一样

	=====================================================================
	class C
    		def initialize
        		@x = 1
    		end
	end
	class D
	    	def twisted_method
        		@y = 2
        		C.new.instance_exec(@y) { |y| "@x: #{@x}, @y: #{y}"}
    		end
	end
	
	puts D.new.twisted_method  
	>@x: 1, @y: 2
	=====================================================================
		


3.ruby块

	Proc对象：Proc是由块转换来的对象。

	================================创建方式=============================
	# 法一
	inc = Proc.new { | x | x + 1}
	inc.call(2)  #=> 3

	# 法二
	inc = lambda {| x | x + 1 }
	inc.call(2)  #=> 3

	# 法三
	inc = proc {|x| x + 1 }
	inc.call(2) #=> 3
	=======================================================================

	还有一种通过&操作符的方式，将代码块与Proc对象进行转换。

	&符号的含义是： 这是一个Proc对象，我想把它当成代码块来使用。去掉&符号，将能再次得到一个Proc对象。

	========================================================================
	def my_method(&the_proc)
    		the_proc
	end

	p = my_method {|name| "Hello, #{name} !"}
	p.call("Bill")   #=> "Hello,Bill"
	========================================================================

	如果需要将某个代码块作为参数传递给方法，需要通过为这个参数添加&符号，并且其位置必须是在参数的最后一个

	=======================================================================
	def my_method(greeting)
	    "#{greeting}, #{yield}!"
	end

	my_proc = proc { "Bill" }
	my_method("Hello", &my_proc)
	========================================================================
	proc与lambda的区别

	a.return的作用域不同

	def fun
    		p = proc { return 10 }
    		result = p.call   
    		return result * 2 
	end

	>result=10

	def fun
    		p = lambda { return 10 }
    		result = p.call   
    		return result * 2 
	end
	
	>result=20

	b.参数检查方式

	p=proc{|a,b| puts a;puts b}
	p.call(1,2) #1 2
	p.call(1)   #1 nil
	p.call(1,2,3)#1 2


	p=lambda{|a,b|puts a;puts b}
	p.call(1,2) #1 2
	p.call(1)   #error
	p.call(1,2,3)#error


4.Method对象

	(1)通过Kernel#method方法，可以获得一个用Method对象表示的方法，在之后可以用Method#call方法对其进行调用。
	
	==========================================================
	class A
	  def fun
	    puts "this is fun"
	  end
	end
	
	obj1=A.new
	m=obj1.method :fun
	m.call
	=========================================================

	(2)自由方法
	它会从最初定义它的类或模块中脱离出来(即脱离之前的作用域)，可以将一个方法变为自由方法。通过调用Module#instance_method获得
	一个自由方法（UnboundMethod对象），通过UnboundMethod#bind方法把UnboundMethod对象绑定到一个对象上；
		从某个类中分离出来的UnboundMethod对象只能绑定在该类及其子类对象上，
		从模块中分离出来的UnboundMethod对象不在有此限制了。
	=========================================================
	class A
		def fun
    			puts "this is fun"
  		end
	end

	um=A.instance_method :fun
	obj=A.new
	m=um.bind obj
	m.call
	==========================================================


5.BasicObject#instance_eval 与 Module#class_eval

	instance_eval必须由实例来调用
	class_eval必须由类来调用
	=========================================================
	class A
  		def self.fun1
    			puts @var
	  	end
  
 		def fun2
    			puts @var
  		end
	end

	obj=A.new
	
	#由于A类是Class类的一个实例，因此就定义了A类的单件方法m1，进而m1只会对A类的实例变量进行操作。
	A.instance_eval do
		 def m1
   			@var=1
	 	 end
	end
	
	#由于obj是A类的一个实例，因此就定义了obj实例的单件方法m2，进而只会对obj的实例变量进行操作。
	obj.instance_eval do
	  	def m2
     			@var=2
  		end
	end
	
	#由于定义了A类的实例方法m3，因此只会对obj的实例变量进行操作。
	A.class_eval do
  		def m3
    			@var=3
  		end
	end

	A.m1  
	A.fun1 #=>1
	
	obj.m2 
	obj.fun2  #=>2

	obj.m3  #=>A.class_eval
	obj.fun2#=>3
	=========================================================


6.单件方法
	
	Ruby允许给单个对象增加方法,这种只针对单个对象生效的方法，称为单件方法
	
	定义方式
	Object#define_singleton_method
	Object#singleton_methods 
	===========================================================
	class A
	end

	obj=A.new

	#方法一
	def obj.fun
	  	puts "this is fun"
	end
	obj.fun #=>this is fun
	puts obj.singleton_methods  #=>fun

	#方法二
	obj.define_singleton_method(:fun2) { puts "this is fun2" }
	obj.fun2  #=>this is fun2
	puts obj.singleton_methods  #=>fun fun2
	
	-----------------------------------------------------------
	Ruby中class也是对象，则类方法也是一个类的单件方法

	def ClassName.fun
	end

	ClassName.define_singleton_method(:fun){}
	===========================================================

	
7.单件类

	单件方法也不能在祖先链的某个位置中。正确的位置是在单件类中
	每个单件类只有一个实例（被称为单件类的原因），而且不能被继承
	每个对象都有一个单件类
	类方法其实质是生活在该类的单件类中的单件方法
	-----------------------------------------------------
	class MyClass
    		class << self
        		def yet_another_class_method
			end
    		end
	end
	----------------------------------------------------

	（1）获取单件类
	Object#singleton_class
	=========================================================
	class A
	end

	obj=A.new
	
	#方法一
	s=class << obj
	  self
	end
	puts s.class  			#=>Class

	#方法二
	puts obj.singleton_class	#=>Class
	=========================================================
	（2）引入单件类后的方法查找

	单件类 => 祖先链

	(3)一个对象的单件类的超类是这个对象的类；一个类的单件类的超类是这个类的超类的单件类。(单件类.png)


8.模块与单件类

	当一个类包含一个模块时，他获得的是该模块的【实例方法】，而不是【类方法】。
	【类方法】存在与模块的【单件类】中，没有被类获得

	（1）类扩展
	通过向类的单件类中添加模块来定义类方法
	==========================================================
	module A
  	  def fun
    	     puts "ok"
	  end
	end

	class B
  	   class <<  self
      	      include A
	   end
	end
	-------------------------或者---------------------------
	class B
	   extend A
	end
	
	B.fun()
	============================================================

	（2）对象扩展
	类方法是单件方法的特例，因此可以把类扩展这种技巧应用到任意对象上，这种技巧即为对象扩展

	================================================================
	module A
	  def fun
	    puts "ok"
	  end
	end

	obj=Object.new
	class << obj
	  include A
	end
	-------------------------------或者---------------------------
	obj.extend A

	obj.fun
	===============================================================
	
	
	
9.方法包装器（Method Wrapper）

	(1)方法别名

	Ruby中使用Module#alias_method(:newName,:oldName)方法和alias(:newName :oldName)关键字为方法取别名。
	============================================================
	class A
	  def fun
	    puts "this is fun"
	  end
  
	  alias_method :fun1,:fun
	end

	obj=A.new
	obj.fun #=>this is fun
	obj.fun1#=>this is fun
	
	在顶级作用域中（main【Object, Kernel, BasicObject】）中只能使用alias关键字来命名别名，因为在那里调用不到Module#alias_method方法
	注意:在alias出现循环时，只看第一条alias语句
	============================================================

	
	(2)环绕别名

		a.给方法定义一个别名
		b.重定义这个方法
		c.在新的方法中调用老的方法


	=========================================================================
	class A
		def fun
		  puts "this is origin function"
		end
		private :fun

		def fun2		#b.重定义这个方法
		  puts "this is head"
		  fun1			#c.在新的方法中调用老的方法
		  puts "this is footer"	
		end
		
		alias :fun1 :fun	#a.给方法定义一个别名
		alias :fun :fun2
	end
	
	A.new.fun
	==========================================================================
	
	(3)细化(refine)
	
	细化的作用范围是文件末尾，而环绕别名则是作用在全局

	==========================================================================
	module StringRefinement
  		refine String do
    			def length
      				super > 5 ? 'long' : 'short'
    			end
  		end	
	end

	puts "War and Peace".length #=>13

	using StringRefinement

	puts "War and Peace".length  #=> “long”
	==========================================================================

	(4)下包含包装器 (Module#prepend)

	prepend是插入到下方，而下方的位置，正好是方法查找时优先查找的位置，利用这一优势，可以覆写当前类的同名方法

	=========================================================================
	module ExplicitString
    		def length
        		super > 5 ? ‘long’ : ‘short’
    		end
	end

	String.class_eval do
		prepend ExplicitString
	end

	puts "War and Peace".length  #=> “long”
	==========================================================================

10.Kernal#eval方法

	(1)与BasicObject#instance_eval和Module#class_eval相比Kernal#eval更加直接，不需要代码块、直接就可以
执行字符串代码(String of Code)。

	BasicObject#instance_eval也是可以执行字符串代码的。

	============================================================================
	eval "puts 'ok'"	  #ok
	instance_eval "puts 'ok'" #ok
	============================================================================

	(2)绑定对象
	Binding是一个完整作用域对象，通过eval方法在这个Binding对象所携带的作用域内执行代码

	=========================================================================
	class MyClass
	    def my_method
        	@x = 1
        	binding
    	    end
	end

	b = MyClass.new.my_method
	eval "puts @x", b #=> 1
	========================================================================

	(3)TOPLEVEL_BINDING的预定义常量,表示顶级作用域Binding对象
	
	========================================================================
	class A
	  def fun
      	      eval "puts a",TOPLEVEL_BINDING
  	  end
	end

	a=3
	A.new.fun 	#=>3
	========================================================================
	

11.钩子方法

	钩子方法有些类似事件驱动装置，可以在特定的事件发生后执行特定的回调函数，这个回调函数就是钩子方法

	(1)Class#inherited
		当一个类被继承时，Ruby会调用该方法
	==========================================================================
	class A
  	  def self.inherited(arg1)
      	  	puts "A被#{arg1}继承"
  	  end
	end

	class B <A
	end
	#=>A被B继承
	===========================================================================
	
	(2)Module#included(Module#prepended)
	===========================================================================
	module A
  	  def A.included(args)
    		puts "#{args}"
  	  end	
	end

	class B
	  include A
	end
	#=>B
	===========================================================================
	(3)Module#extend_object
	===========================================================================
	module A
	  def A.extend_object(arg1)
	    puts "#{arg1}"
	  end
	end

	class B
	  extend A
	end
	#=>B
	===========================================================================
	(4)Module#method_added(Module#method_removed或Module#method_undefined)
	module A
	    def A.method_added(arg1)
	      puts "#{arg1}"
	    end
	    def fun
	    end 
	end
	#=>fun

	module A
	    def A.method_added(arg1)
	      puts "#{arg1}"
	    end
	    def fun
	    end 
	    remove_method :fun
	end
	#=>fun

	module A
	    def A.method_added(arg1)
	      puts "#{arg1}"
	    end
	    def fun
	    end 
	    undef_method :fun
	end
	#=>fun
	===========================================================================
	(5)BasicObject#singleton_method_added(BasicObject#singleton_method_remove或
	BasicObject#singleton_method_undefined)
