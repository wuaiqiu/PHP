# Mysql锁机制

一.表级锁定（table-level）

>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发大度大打折扣。使用表级锁定的主要是MyISAM等一些非事务性存储引擎。


MySQL表级锁的锁模式

```
MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。
    对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
    对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；

>show status like 'table%';
    Table_locks_immediate：产生表级锁定的次数；
    Table_locks_waited：出现表级锁定争用而发生等待的次数；
```

<br>

二.行级锁定（row-level）

>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。


InnoDB锁定模式

```
InnoDB的行级锁定分为:共享锁和排他锁
    如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。
    如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。
    
InnoDB的表级级锁定分为:共享锁和排他锁，意向共享锁和意向排他锁
    意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候（由mysql自动加锁，由于节省扫描整张表每行是
    否加锁）:
        如果自己需要行级共享锁，那么就在表上面添加一个意向共享锁。意向共享锁与表级共享锁，意向共享锁，意向排他锁可以同时并存；
        如果自己需要行级排他锁，那么就在表上面添加一个意向排他锁。意向排他锁与意向共享锁，意向排他锁可以同时并存；
```

```
其他:
a.对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；但可以通过以下语句显示给记录集加
共享锁:SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
b.在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
c.如果不同的结果集是使用相同的索引键，可能出现锁冲突的。
d.即便在条件中使用了索引字段，但对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。
e.MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需
要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。
```

```
死锁
在InnoDB发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会
被回滚掉。或者通过锁定超时限制参数InnoDB_lock_wait_timeout来解决。
```

```
>show status like 'InnoDB_row_lock%'

InnoDB_row_lock_current_waits：当前正在等待锁定的数量；
InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；
InnoDB_row_lock_time_avg：每次等待所花平均时间；
InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；
InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；
```

<br>

三.并发控制

>悲观并发控制（悲观锁）:每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，如上面的锁机制即是悲观锁


>乐观并发控制（乐观锁）:每次去拿数据的时候都认为别人不会修改，所以不会上锁，只有在提交操作的时候检查是否违反数据完整性;使用版本标识来确定读到的数据与提交时的数据是否一致
