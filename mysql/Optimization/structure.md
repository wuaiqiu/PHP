# 结构优化

**1.合适的数据类型**

>a.使用可以存下你的数据的最小的数据类型


>b.使用简单的数据类型，int要比varchar类型在mysql处理上简单


>c.尽可能的使用not null定义字段


>d.尽量少用text类型，非用不可时最好考虑分表

<br>

**2.结构优化**

```
#用int来存储日期时间

>create table test(id int primary key,timestr int);
>insert into test values(1,unix_timestamp('2018-03-20 14:00:00'));
>select id,from_unixtime(timestr) from test;
```

```
#用bigint来存储ip地址

>create table sessions(id int primary key,ip bigint);
>insert into sessions values(1,inet_aton('192.168.0.1'));
>select id,inet_ntoa(ip) from sessions;
```

<br>


**3.范式化与反范式化**

>范式化（一般指第三范式）

商品id|商品|价格|重量|分类|分类描述
--|--|--|--|--|--
1|可乐|3.00|250ml|饮料|碳酸饮料
2|北冰洋|3.00|250ml|饮料|碳酸饮料


```
存在传递依赖
(商品id)-->(分类)-->(分类描述)
```

商品id|商品|价格|重量
--|--|--|--
1|可乐|3.00|250ml
2|北冰洋|3.00|250ml

分类|分类描述
--|--
饮料|碳酸饮料

商品id|分类
--|--
1|饮料
2|饮料

>反范式化（对表增加冗余字段，以空间来换取时间）

用户id|姓名|地址|电话
--|--|--|--
1|张三|东湖区|123456
2|李四|西湖区|789012

订单id|用户id|下单时间
--|--|--|--
1|2|2018-03-12 13:30:44
2|2|2018-03-12 13:40:01

```
当查询订单信息时（利用了连接查询）:
select A.用户id,A.姓名,A.地址,A.电话,B.订单id,B.下单时间 from A inner join B on A.用户id = B.用户id;
```

用户id|姓名|地址|电话
--|--|--|--
1|张三|东湖区|123456
2|李四|西湖区|789012

订单id|用户id|下单时间|姓名|地址|电话
--|--|--|--|--|--
1|2|2018-03-12 13:30:44|李四|西湖区|789012
2|2|2018-03-12 13:40:01|李四|西湖区|789012

```
反范式化后:
select 用户id,姓名,地址,电话,订单id,下单时间 from B;
```

<br>

**4.表的拆分**

>垂直拆分:就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常的拆分可以按以下原则进行

```
a.把不常用的字段单独存放到一个表中
b.把大字段独立存放的一个表中
c.把经常一起使用的字段放在一起
```

>水平拆分:为了解决单表的数据量过大问题，水平拆分的表每一个表的结构都完全一致的，常用的拆分方式

```
a.对id进行hash运算，如果要拆分成5个表则使用mod(id,5)取出0-4个值
b.针对不同的hash把数据存到不同的表中
```